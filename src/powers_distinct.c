/* Consider all integer combinations of 
 * a**b for 2 <= a <= 5 and 2 <= b <= 5:

 * If they are then placed in numerical order, 
 * with any repeats removed, we get
 * the following sequence of 15 distinct terms:

 * 4, 8, 9, 16, 25, 27, 32, 64, 
 * 81, 125, 243, 256, 625, 1024, 3125

 * How many distinct terms are in the 
 * sequence generated by ab for 2 <= a <= 100 
 * and 2 <= b <= 100?

 * Project Euler: 29
 * Answer: 9183 
 * Runtime of 0.167u */

/* The funny thing about this one is 
 * that a solution in Python is a mere
 * line away. 

 * r = range(2,101); 
 * print(len({a ** b for a in r for b in r})) */


/* Includes */
#include <stdio.h>
#include <stdlib.h>
#include <gmp.h>


/* Definitions */
#define MAX     100

/* Generate a linked list capable of
 * storing mpz_t sized integers */
typedef struct node node;
struct node {
        mpz_t value;
        struct node *next;
};


/* Function prototypes */
int main();
int isDistinct(mpz_t power, node *head);
void push(node *current, mpz_t val);


int main()
{
        /* Define our HEAD for linked list */
        node *head = NULL;
        head = malloc(sizeof(node));

        mpz_t power;
        mpz_init(power);

        int count = 0;

        unsigned long int a; unsigned long int b;

        for(a = 2; a <= MAX; a++){
                for(b = 2; b <= MAX; b++){
                        mpz_ui_pow_ui(power, a, b);
                        count += (isDistinct(power, head)) ? 1 : 0;
                }
        }
                                     
        printf("%d\n", count);

        return 0;
}
         

/* Iterates over the linked list; if 
 * the power is in the list, breaks and 
 * returns false otherwise appending */
int isDistinct(mpz_t power, node *head)
{
        node *current = head;

        for(; current->next != NULL; current = current->next){

                /* mpz_cmp returns 0 if they are equal 
                 * most correct to check equality with 0
                 * as it also returns other ints */
                if(!mpz_cmp(current->value, power)){
                        return 0;
                }

        }

        push(current, power);

        return 1; 
}


/* Here we push the value into a new node on
 * the end in the assumption that: 1) It has
 * already been totally iterated over; and 2)
 * All duplicate values have been caught */
void push(node *current, mpz_t val)
{
	/* Now we can add a new variable */
	current->next = malloc(sizeof(node));
        mpz_init(current->next->value);
	mpz_set(current->next->value, val);

	current->next->next = NULL;
} 

